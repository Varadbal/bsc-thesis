%----------------------------------------------------------------------------
\chapter{Conclusion} \label{chapter_conclusion}
%----------------------------------------------------------------------------
The Gamma Statechart Composition Framework is a modeling tool that supports the design, verification and code generation for reactive embedded systems. It applies model-driven software development concepts to the modeled state-based systems by supporting the use of hidden formal methods -- high-level language elements designed for formal verification -- and also Java code generation.

The main contribution of this work is the design and integration of an action language into the Gamma Framework, that can describe the behavior typically required of embedded systems, while also enabling the application of formal verification techniques for the language elements. This can be achieved by remaining within the boundaries of the finite-state machine formalism (and intentionally avoiding Turing completeness of the language).

The language supports different types of value declarations (variable, constant, parameter), expressions, state modification actions (variable assignments, event raisings, timeouts), control flow statements (if-else, switch-case, for-then, choice, assertion) and procedures. Its type system contains the ordinary primitive types such as integers and booleans, but also enumerations, bounded integers, arrays, records and integer ranges. 

The language definition precisely describes the concrete syntax using the EBNF notation in accordance with the metamodel of the language, well-formedness constraints in the form of validation rules, and also denotational semantics for the transformation of the models to various other formalisms. The model transformations are executed in multiple steps: first of all, a low-level model is generated, which reduces the set of the applied metamodel elements and eliminates most of their redundancy. Next, the low-level model is transformed to the xSTS formalism, which only contains a handful of language elements. This xSTS model can be formally verified, and it is also suitable for the transformation to Java code, which task is delegated to the Gamma Framework.

The case study of the RPN calculator demonstrated the capabilities of the action language: similarly to other, general purpose imperative programming languages, it can be used to implement various algorithms for the solution of complex problems. The algorithms written in other languages are easily portable to the introduced action language, and in many cases, their capabilities are not limited by the restrictions applied to it. However, the case study also demonstrated the dangers and boundaries of the application of the language: even though it seemed to work for simple models, the brute-force solutions during the model transformations resulted in a state-space explosion so huge, that the calculator could not be executed in a basic environment. 

As for future work, the most pressing task is the optimization of the model transformations. Based on previous experience, it is not impossible at all: by changing the code in one place, the generated Java files could be reduced to around one sixth of their original sizes (which still proved to be impossible to execute). Then, the not yet integrated language elements should be integrated into the Gamma Framework, along with the extensive validation of the behavior of the individual language elements. 

By designing an imperative programming language that can be formally verified, but also offers high-level language elements, and integrating it into the Gamma Framework -- a powerful tool used for modeling state-based systems -- we hope to support software and system engineers to take advantage of the full potential of model-driven software development.

The action language is available as part of the Gamma Statechart Composition Framework publicly accessible on GitHub under the following link: https://github.com/FTSRG/gamma. \newline The model transformations to the low-level and xSTS models and the Java language are not yet publicized, but are available upon request.