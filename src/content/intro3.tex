%----------------------------------------------------------------------------
\chapter{\bevezetes} \label{chapter_intro}
%----------------------------------------------------------------------------

Due to the increasing complexity of embedded systems, and software systems in general, the design, implementation and analysis of these systems is getting more and more difficult directly handling the source code. Thus, the modeling of these systems should happen on a higher level of abstraction. 
 %---
%One feasible way to implement that is the so-called \textit{model-driven development} paradigm. This is the motivation of the Gamma Statechart Composition Framework, with an additional goal of supporting formal verification, deatiled in \cite{GammaVince2018} and briefly discussed in Section \ref{section_background_target}. This thesis will introduce an action language to the mentioned framework, with the possibility of formal verification by supporting the automated transformation of the code to one that can be checked by the Theta Framework, detailed in \cite{ThetaToolPaper} and discussed in Section \ref{section_background_target}. The automated transformation of the written code to Java code also enables its execution.
%---

In theory, it would be possible to automatically generate source code and formally verify the correctness of behavior solely using the models of a given system. This is the goal of the \textit{model-driven software development} methodology. However, engineering models made for a certain purpose (e.g. communication, visualization or documentation) often lack the precisely defined semantics, or at times even syntax required for these purposes. In some cases, like the UML 2.1.2 standard, \textit{"implementors may provide [...] informal feature support statements [...] for less precisely defined dimensions such as presentation options and semantic variation points"} \cite{UMLStandard212}, which feature deliberately discards the mathematical strictness in exchange for ease of communication. Attempts have been made to tackle this problem and define variability within modeling languages, for instance in \cite{VariabilityInModelingLanguages}.

Some modeling languages, especially those used in formal methods, possess not only the syntax and metamodel, but also the semantics and well-formedness constraints in a strict mathematical manner. Examples for these models include most mathematical models of computation (Turing machine, finite-state machine) or the extended timed automata of the UPPAAL tool. The drawback of these models is the difficult application for engineering tasks, as they operate on lower abstraction levels, often with limited expressive power and strongly mathematical syntax.

Reactive systems can be described using several kinds of \textit{behavioral models}. One of the most practical ways of modeling these systems is the \textit{statechart} formalism -- one formalism for state-based models. The reason for this practicality is the relative simplicity and visual representation of the models, that facilitates not only the design, but also the analysis of these systems. The Gamma Statechart Composition Framework, deatiled in \cite{GammaVince2018} also applies this formalism for modeling component-based reactive systems, with an additional goal of supporting hidden formal verification techniques on the system models.

The specification of the reactions of these systems to the events of the outside world is most efficient in a procedural manner. For this reason, most statecharts have some sort of \textit{action language} to bridge the gap between state-based and process-based modeling. The different action languages of existing modeling tools are usually designed to solve a particular problem: some can be directly used for execution or code generation, some can be used for formal verification, and some are useful for communication at the expense of precisely defined semantics. 

This thesis will introduce an action language to the Gamma Framework, with the intention to address this situation and extend the above mentioned tool with a both mathematically precise and from an engineering standpoint convenient feature. Formal verification and execution is achieved through the definition of precise \textit{denotational semantics} -- i.e. by transforming the model to various models designed for specific purposes. 

An important aspect taken into account when designing the action language was the ease of use and the convenient description of the behavior common to embedded systems, by supporting well-known control statements and data structures of 3rd generation programming languages. Examples for these control statements are the \textit{if-else}, \textit{switch-case} and \textit{for} statements. For data structures, currently \textit{array} (indexable groups of variables of the same type) and \textit{record} types (groups of variables of possibly different types) are supported in addition to primitive types. This results in a C-like programming language, with some features resembling the UML textual syntax and a fairly high expressive power. Turing completeness is intentionally avoided to ensure the decidability of the verification problems.
The language is efficiently verifiable using formal methods, as -- by not being computationally complete -- the algorithms written in this action language are always guaranteed to terminate. Thus, it is possible for a model checker to exhaustively analyze the state-space of the system and prove or disprove the correctness of its functionality.
%Vince: btw a statecharttal egy√ºtt Turing teljes is lehet

It is integrated into the Gamma Statechart Composition Framework, using its type system and expression language, also being extended by it with statechart-specific elements, such as \textit{event raising} and \textit{timeout}-related statements. Automated transformations are currently supported to Java and xSTS codes -- the latter being used by the Theta Framework detailed in \cite{ThetaToolPaper} --, enabling the execution and formal verification of the designed system models.

The rest of the thesis is structured as follows. Chapter \ref{chapter_background} presents the theoretical background behind modeling formally verifiable reactive systems. It also explores the existing modeling tools, with special regard to their action languages, and also the targeted framework used by and using the action language detailed in this work. Chapter \ref{chapter_theoreticalResults} describes the various features and capabilities of the action language, describing the syntax, semantics and the motivation behind each of its constructs, as well as providing the reader with examples of the usage of each of the language elements. Chapter \ref{chapter_implementation} presents the tools and details of the implementation and integration into the Gamma Framework. The applicability and usefulness of the introduced action language is discussed in Chapter \ref{chapter_results}, along with the validation methods applied to each of the contained elements. Finally, Chapter \ref{chapter_conclusion} provides concluding remarks and possibilities for further improvement.